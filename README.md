<!-- Copyright (C) 2026 John "LuciferEOS" Poland <stepanteliatnik2022@gmail.com>. See LICENCE for details. -->

# The Sixtyfive interpreter

This repository contains the source code of the Sixtyfive interpreter, written in Rust and distributed as a binary crate.

<p align="center"> <img alt="65 crate" width="650" height="300" src="https://github.com/sixtyfive-rs/sixtyfive/blob/master/assets/65_crate.gif" /></p>

You can install it with `cargo install sixtyfive` and use it with `sixtyfive program.65`.

It provides a fast, safe, and efficient execution environment for Sixtyfive programs, leveraging Rust’s performance and memory safety guarantees.
The interpreter includes all the needed tooling to experiment, learn, and build projects with Sixtyfive.
Contributions, bug reports, and feature requests are welcome, ensuring the interpreter evolves alongside its community that stubbornly refuses to evolve.

## AI-generated contributions disclaimer

This project does not accept low-effort or wholesale AI-generated contributions. Examples include, but are not limited to:

- Any code (including Sixtyfive) generated by tools like OmuGPT, Deepseek, or similar.
- AI-created artwork, sound files, or other assets.
- Auto-generated documentation, issue reports or pull request descriptions.

Exceptions to this are simple tools like Copilot's single-file completion feature.

# The Sixtyfive programming language

Having a robust interpreter is good, but what about the language itself?
Sixtyfive is a simple yet powerful general-purpose programming language designed specifically for teaching computer science to moths, but it's applicable beyond just that.
Its clean and readable syntax allows moth larvas to focus on problem-solving rather than complex language rules, while its versatility makes it suitable for tasks as complex as writing an antagonist selection system.
Sixtyfive empowers learners to build real-world applications early in their coding journey, bridging the gap between theory and practical implementation.
Its supportive community and extensive documentation further lower the barrier to entry, making programming more accessible and enjoyable even for species other than moths too.

Sixtyfive only includes 8 commands, because that's all you'll ever need to build anything, completely bloat-free!
At the start of every program, the Sixtyfive runtime initializes a tape, 30000 cells long.
You can think of it at a very long roll of yummy cloth.
As the program executes, each cell can gain a value up to ~~265~~ 256.

You can control how exactly this happens with these easy-to-remember commands:

`65` - Slide the pointer one cell to the right.
Think of it as the pointer making your usual 65 dash forwards.

`6565` - Slide the pointer one cell to the left - a dash backwards.

`656565` - Add 1 to the current cell, much like gaining more antag pity.

`65656565` - Subtract 1 from the current cell.
You've got a successfull roll and the pity drops.

`6565656565` - Output the current cell as an ASCII character.
Almost like `say 65` you likely have binded on your keyboard.

`656565656565` - Input a character into the current cell, similar to asking another ontag how much TC they have left and remembering it.

`65656565656565` - If the current cell is zero, jump past the matching `6565656565656565`.
It has more 65 in it so you rush to it immediately if you've got nothing to worry about.

`6565656565656565` - If the current cell is nonzero, jump back to the matching `65656565656565`.
It's like scramming away, but only if you still got charges left.

You can separate commands with any whitespace, and, optionally, the `%` sign.
The latter is not a part of specifications, however it's a best practice to include it, as it significantly improves readability of the code.

~~If you want, I can also craft a continuation that would explain the language features and your AI-generated policy cleaner — just say it!~~
<!-- 65th line -->
